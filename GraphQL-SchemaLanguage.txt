.....................................................................................
	GraphQL - Server Side : GraphQL Schema language spec and implementation
...................................................................................

How to build rest applications?

 Restfull web services are built based on "resources" in the problem domain.

Resource represents a Object which expose data 


eg: CustomerResource,OrderResource,ProductResource
Resources are identified by URL /api/customers and Method "GET | POST | PUT |DELETE "
	
How to build graphql applications?
 
Graphql apps are built based on Objects called "Models".

What ever lanaugage we have to think in terms of Objects.

Object shape is described by "schema".

Schema is nothing but plan /design.

Schema represents the Object design

In Graphql The design is represented by "GraphQL schema Lanaguage"
.....................................................................................

.....................................................................................
			  SDL - Schema definition language
.....................................................................................

SDL Core concepts:

1.Type System:
   The Type system defines the Platform indenpendent data types and variable which describe what data can be queired by client.


query getUserData {
 
   user {
	name             =>SDL=>|SDL|===>Enity==>Biz logic(Services)====>DataSources
   }

}
Both Servers and clients talks via common language called SDL...

SDL provides language independant abstraction
				 
				|---- Java/Kotlin/scala --Jvm
			SDL-----|-----js/ts ----node


Syntax:

type TypeName {
   field:DataType
}
In SDL , there is root type , every type is dervied from the root type

type schema{
  query:Query
  mutation:Mutation
  subscription:Subscription
}
type Query {
  #apis
}

type Mutation { 
 #apis
}

type Subscription{
 #apis
}

Query Type:

In Server Side:

type Query {
  #apis
  greet:String
  user:User
  user(id:Int):User
}
Client Side
query {
 #api- sending request for invocation at server
  greet
}

query {
 #api
 user {
   id
   name
 }
}
query {
 #api
 user(id:1) {
   id
   name
 }
}

Server side

type Mutation { 
 #apis
 createUser(user:User):User
}

ClientSide:

mutation CreateUser($user:User){
  
   createUser(user:$user){
     id
     name
   }
}
SDL Defines schema language and platform independant data types:
.............................................................
1.Scallar types
2.Custom Types/ReferenceTypes/Object Types


1.Scallar Types:
  Scallars are like primitive types in your language

1.Int -32 bit signed integer
2.String - UTF-8 char Sequence
3.Boolean - true or false
4.Float - singed double 
5.ID (Serialized String)- A unique identifier

2.Object Type/Complex/User Defined/Reference Type
 Similar to classes in object oriented languages- like java,C#

type User{
  id:ID
  firstName:String
  lastName:String
  age:Int
  points:Float
  status:Boolean  
}


Object Type can have other Object Type :
  Like has a relationship/ Dependency injection

type Address {
  city:String
  state:String
  zipcode:String
}

type User{
  id:ID
  firstName:String
  lastName:String
  age:Int
  points:Float
  status:Boolean 
  address:Address
}

type Query{ 
  user:User
}

Client side
query getUser{
  user {
   id
   firstName
   address {
     city
   } 
  }
}

....................................**********......................................
....................................................................................
			  Handling null and not null values
...................................................................................

Client Query With data
{
  name  --------> response {name:"subramanian"}
}

Client Query Without data
{
  name  --------> response {name:null}
}

I dont want null value for a given field? How to force the field must have data or must not have null?
 => not null fields

syntax:
 fieldName:Type!
!(not null)

type Address {
  city:String
  state:String
  zipcode:String
}

type User{
  id:ID!
  firstName:String!
  lastName:String
  age:Int
  points:Float
  status:Boolean 
  address:Address
}
.....................................................................................
				...................................................................................
			  Collection - List of Similar Values
..................................................................................

The field may have more values

 fieldName:[DataType]

  DataType here can be Scalar or Object type
 eg:
 fieldName:[String] | [Int] [Float]
 fieldName:[Address] [Order] [Items]

.....................................................................................
...................................................................................
			    Advanced Types

=>Mutation 
=>Subscription
=>Input
=>Enum
=>Union
=>Interface

Mutation:
  The Mutation is similar in Strcuture and purpose to the Query Type.

Where as Query is read only operations, where as "Mutation" is entry points for "Write and Read" operations

Signature of the Mutation:
.........................

type Mutation {
   createUser(id:ID,firstName:String,lastName:String,age:Int):User 
   updateUser(id:ID,user:User):User
   removeUser(id:ID):User
}
....................................................................................
			  Input Types
...................................................................................

Input types are special Object types that allow you to provide hierarchical data as arguments to fields( as apposed to providing only flat scalar arguments)

type Mutation {
   #Flat scalar arguments
   createUser(id:ID,firstName:String,lastName:String,age:Int):User 
}

type Address {
  city:String!
  state:String!
  zipcode:String
}


type User{
  id:ID!
  firstName:String!
  lastName:String
  age:Int
  points:Float
  status:Boolean 
  address:[Address!]!
}

input UserInput { 
  id:ID!
  firstName:String!
  lastName:String
  age:Int
  points:Float
  status:Boolean 
  address:[Address!]!
}

Mutation without inputType
type Mutation {
   #Flat scalar arguments
   createUser(id:ID,firstName:String,lastName:String,age:Int):User 
}
//Mutation with inputType
type Mutation {
   #Using Input Type
   createUser(userInput:UserInput):User
}
....................................................................................
				Enums
....................................................................................

An Enum is similar to scalar type, but its legal values are defined in the schema.

enum Gender {
 MALE
 FEMALE
 THIRD
}
How to use Enum?

type Query {
  gender:Gender
}
.....................................................................................
		  Union and Interfaces
...................................................................................

Unions and interfaces abstract GraphQL types that enables a schema field to return one of multiple object types.

union  Media= Image | Video

type Query {
 # This list can include both Image and Video Objects
 getMedia:[Media] 
}

Note:
  Union types must be only Object types not scalars or input types.
....................................................................................
...................................................................................
			    Advanced Types

=>Mutation 
=>Subscription
=>Input
=>Enum
=>Union
=>Interface

Mutation:
  The Mutation is similar in Strcuture and purpose to the Query Type.

Where as Query is read only operations, where as "Mutation" is entry points for "Write and Read" operations

Signature of the Mutation:
.........................

type Mutation {
   createUser(id:ID,firstName:String,lastName:String,age:Int):User 
   updateUser(id:ID,user:User):User
   removeUser(id:ID):User
}
....................................................................................
			  Input Types
...................................................................................

Input types are special Object types that allow you to provide hierarchical data as arguments to fields( as apposed to providing only flat scalar arguments)

type Mutation {
   #Flat scalar arguments
   createUser(id:ID,firstName:String,lastName:String,age:Int):User 
}

type Address {
  city:String!
  state:String!
  zipcode:String
}


type User{
  id:ID!
  firstName:String!
  lastName:String
  age:Int
  points:Float
  status:Boolean 
  address:[Address!]!
}

input UserInput { 
  id:ID!
  firstName:String!
  lastName:String
  age:Int
  points:Float
  status:Boolean 
  address:[Address!]!
}

Mutation without inputType
type Mutation {
   #Flat scalar arguments
   createUser(id:ID,firstName:String,lastName:String,age:Int):User 
}
//Mutation with inputType
type Mutation {
   #Using Input Type
   createUser(userInput:UserInput):User
}
....................................................................................
				Enums
....................................................................................

An Enum is similar to scalar type, but its legal values are defined in the schema.

enum Gender {
 MALE
 FEMALE
 THIRD
}
How to use Enum?

type Query {
  gender:Gender
}
.....................................................................................
		  Union and Interfaces
...................................................................................

Unions and interfaces abstract GraphQL types that enables a schema field to return one of multiple object types.

union  Media= Image | Video

type Query {
 # This list can include both Image and Video Objects
 getMedia:[Media] 
}

Note:
  Union types must be only Object types not scalars or input types.
....................................................................................
			 Interface

Interface represents common fields that multiple objects can include.

interface Book {
 title:String!
 author:String!
}

type TechnicalBook implements Book {
 title:String!
 author:String!
 X:String
}

type StoryBook implments Book {
 title:String!
 author:String!
 Y:String
}

Query:
type Query {
  books:[Book]
}

Client Side: How to Query data Based on Interface

Syntax: 1 
query GetBooks{
  books {
   author
   title
  }
}

Here it returns all data ,

What if i want Technical and story book details with clear values

query GetBooks{

 books {
 
   __typename
   title
   ... on TechnicalBook {
      X
   }
   ... on StoryBook {
     Y
   }
 }
.....................................................................................	
.....................................................................................
			 Custom Scalar
.....................................................................................
GraphQL SDL provides basic core scalars - Int,String,Boolean,ID,Float.
What if i want other data types like Date,Time


How to define custom scalar

scalar  Date

type User {
 dob:Date
}

Here Date is custom Scalar, but how this data type is represented /logic of this type is provided through "Server side code"
.....................................................................................
.....................................................................................
				GraphQL Application Dev
.....................................................................................


Work Flow
1.SDL must be there and must be very clear.

GraphQL Application can be written in any language

Java:
1.graphql-java
2.SpringBoot with Graphql
3.DGS Framework - Netflix

Javascript:

1.graphql.js
   =>core framework written by facebook
   =>Express.js is underlaying framework

2.Apollo
    Apollo is platform for building enterprise graphql application.
    The core of Apollo is "graphql.js and Express.js"
 Graphql application can be built using two arch
 1.monolith arch
 2.Microservices arch.

Apollo Core concepts:
  SuperGraph:
      Collection of small graphs called subgraph
      A unified network of your organizations microservices and their datasources
      -All Composed into a single distributed API.

  SubGraph:
      It represents a single Graph application

  Graph OS:
     It is cloud platform which hosts supergraph and router

   Router :
      It is compostion api , clients will communicate only Router
     Router internally stiches the schema for data reterival.

Components of Apollo:
.....................
1.Apollo Server : node js server written in express.js
2.Schema defintions - SDL
3.Resolvers - Schema Implementations like queries,mutations,subscription
4.Data Sources -  Database,rest api, any other apis.

Apollo code can be written in "javascript or typescript".

Project Setup:
...............

1.create project folder
E:\session\Prudentia\B2>mkdir apollo-gettingstarted

2.create package.json
E:\session\Prudentia\B2\apollo-gettingstarted>npm init --yes
Wrote to E:\session\Prudentia\B2\apollo-gettingstarted\package.json:

{
  "name": "apollo-gettingstarted",
  "version": "1.0.0",
  "description": "",
  "main": "index.js",
  "scripts": {
    "test": "echo \"Error: no test specified\" && exit 1"
  },
  "keywords": [],
  "author": "",
  "license": "ISC"
}
3.launch code window
E:\session\Prudentia\B2\apollo-gettingstarted>code .
4.create source dir
E:\session\Prudentia\B2\apollo-gettingstarted>mkdir src

5.install dependencies
npm i @apollo/server graphql

Typescript dependency
npm i --save-dev typescript @types/node

package.json
  "dependencies": {
    "@apollo/server": "^4.9.1",
    "graphql": "^16.8.0"
  },
  "devDependencies": {
    "@types/node": "^20.5.3",
    "typescript": "^5.1.6"
  }

6.create ts config file
tsconfig.json
{
    "compilerOptions": {
        "rootDirs": [
            "src"
        ],
        "outDir": "dist",
        "lib": [
            "ES2020"
        ],
        "target": "ES2020",
        "module": "ESNext",
        "moduleResolution": "node",
        "esModuleInterop": true,
        "types": [
            "node"
        ]
    },
}

package.json - scripts configuration
  "scripts": {
    "compile": "tsc",
    "start": "npm run compile && node ./dist/index.js"
  }

Write code inside src/index.ts
.....................................................................................

Getting Started with Code:
...........................

Steps:
1.Define schema
2.Write logic - Resolver
3.Start Apollo Server.


src/index.ts

Step 1:

//Define schema
const typeDefs = `
type Query{
    hello:String
}

`

Step 2:
//Biz logic for api (hello)
const resolvers = {
    //Query 
    Query: {
        //method/api implementation
        hello() {
            return "Hello GraphQl!"
        }
    }
    //Mutation

    //Subscription
}




















